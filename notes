INDEXS
======
    
    Summary of Abtract Data Types and Algorithm. However, it describes some
    concepts to clear contents.

TABLE OF CONTENTS
=================

    Information
    Data
    Algorithms
    Algorithm's complexity
    Big-O
    Vectors
    Grids
    Strings
    Stacks
    Queues
    Recursion
    Recursive Backstacking
    Exhaustive search
    Sorting
    Linked Lists
    Binary Heaps
    Trees
    Binary Search Trees
    Graphs
    Hashing
    DFS
    BFS
    Dijktra
    A*
    Skip Lists
    Bloom Filters

INFORMATION
===========

    It describe properties of things. It is impossible to show "How is
    INFORMATION look like?" because INFORMATION is abstract concepts. For
    example, two lines below describes a person then meaning of two lines is
    INFORMATION:

        name: kevin leptons
        gender: male

    As above, name and gender describes for a person, but it is not all. In
    real world, a small thing to a big thing also contains many INFORMATION
    and human still not able to know INFORMATION is limited or not. Why?,
    because Physical Science always find new particulate matter, smaller and
    they can not proof that "There are smallest particulate matter". Computer
    Science knows that INFORMATION is big and find the way to work with it.

    Don't misstake INFORMATION and DATA. As above example, meaning of two
    lines is INFORMATION, not two lines. Two lines is DATA and will be present
    below.

DATA
====

    It is things represents for INFORMATION. Good news, it is able to show
    "How is DATA look like?". For example, with name and gender of a person,
    human use writting language to represent to that's INFORMATION, and it is
    DATA:

        name: kevin leptons
        gender: male

    Now, above DATA have 19 + 12 = 31 characters. Characters is English
    alphabet. And of course, characters is able to see.

    INFORMATION can be represents by more than one DATA. Here is DATA in
    Spanish version with same INFORMATION above:

       nombre: kevin leptons
       g√©nero: masculino 

       <by translate.google.com>

ALGORITHMS
==========

    It is describes "How to work with DATA?". ALGORITHM includes three parts:

        Input: describes source DATA
        Output: describes destination DATA
        Operations: describes how to get destination DATA from source DATA
    
    For examples, here is ALGORITHM to find person with name:

        Input: List of person
        Output: 
            On found return first person who have name
            On not found return NOT_FOUND
        Operations:
            for each person in Input:
                if name of person is same with name:
                    return person
            return NOT_FOUND

    Defination above use PESUDO_CODE but ALGORITHM can be show by any things
    such as paragraphs, images, sound or videos and it describes INPUT_DATA,
    OUPUT_DATA, OPERATIONS.

ALGORITHM'S COMPLEXITY
======================

    ALGORITHM_COMPLEXITY is function show "How OPERATION_AMOUNT change while
    input's DATA_AMOUNT change?" and applies for number ALGORITHM.

    Why ALGORITHM_COMPLEXITY applies for only number ALGORITHM?. Because it's
    definition related with two concepts OPERATION_AMOUNT which base on
    numbers.

    OPERATION_AMOUNTS is quantitive of OPERATIONS. It is calculates by sum all
    of PRIMITIVE_OPERATIONS. PRIMITIVE_OPERATIONS applies for operations with
    numbers, include: ADD, SUB, MUL, DIV, ASN, >, >=, <, <=, ==. Binary
    numbers have more PRIMITIVE_OPERATIONS, include: SHIFT, AND, OR, NOR, XOR.
    Quanlity of each PRIMITIVE_OPERATIONS is one. 

    DATA_AMOUNT is quantitive of DATA, any DATA is quantitive. It is number of
    element of data. In this case, it is number of element of input data.

    For example, here is ALGORITHM to find smallest number from numbers and
    complexity of it:

        Input: List with n numbers
        Output: First smallest number
        Operations:
            smallest = input[0]                     // 1
            i = 2                                   // 1
            for:                                    // n
                if (i == n):                        // 1
                    break;
                if (input[i] < smallest):           // 1
                    smallest = input[i]             // 1 is wrost case
                i = i + 1                           // 1
            return smallest

    In last loop, it only check i == n and then exit from loop. Complexity of
    above ALGORITHM is: 
    
        f(n) = 1 + 1 + (n - 1)(1 + 1 + 1 + 1) + 1
             = 4(n - 1) + 3
             = 4n - 1

BIG-O
=====

    BIG-O is notation show "What biggest factor affected to
    ALGORITHM_COMPLEXITY?". In simple, from complexity function, remove all
    of constants and chose biggest factor and it is BIG-O.

    For above example of ALGORITHM_COMPLEXITY:

        Complexity function: f(n) = 4n - 1
        Strip all of constants: g(n) = n
        Chose biggest factor: BIG-O = O(n)

    Let work with more complex ALGORITHM, here is ALGORITHM to sort an list of
    number by increasing. In this case, detect correct ALGORITHM_COMPLEXITY
    function is not neccessary. Best is use worst case of loop and strip for
    constants.


        Input: List of n numbers
        Output: List of n numbers by increasing
        Operations:
            for (i = 0; i < n - 1; i++):                // 2(n - 1)
                for (k = i + 1; k < n; k++):            // 2(n - 1)
                    if (input[i] > input[k]):           // 1
                        tmp = input[i]                  // 1
                        input[i] = input[k]             // 1
                        input[k] = tmp                  // 1
            return input

        Worst complexity function: f(n) = 2(n - 1).2(n - 1)(1 + 1 + 1 + 1)
                                        = 16(n^2 -2n - 1)
        Strip all of constants: g(n) = n^2 - n
        Chose biggest factor: BIG-0 = O(n^2)
