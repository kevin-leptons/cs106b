INDEXS
======

    Summary of Abtract Data Types and Algorithm. However, it describes some
    concepts to clear contents.

TABLE OF CONTENTS
=================

    Information
    Data
    Data structure
    Algorithm
    Algorithm's complexity
    Big-O
    ADT

    Arrays
    Vectors
    Stacks
    Queues
    Priority Queues
    Grids
    Strings
    Maps
    Trees
    Binary Heaps
    Binary Search Trees
    Graphs

    Linked Lists
    Recursion
    Recursive Backstacking
    Exhaustive search
    Sorting
    Hashing
    DFS
    BFS
    Dijktra
    A*

    Skip Lists
    Bloom Filters

INFORMATION
===========

    It describe properties of things. It is impossible to show "How is
    INFORMATION look like?" because INFORMATION is abstract concepts. For
    example, two lines below describes a person then meaning of two lines is
    INFORMATION:

        name: kevin leptons
        gender: male

    As above, name and gender describes for a person, but it is not all. In
    real world, a small thing to a big thing also contains many INFORMATION
    and human still not able to know INFORMATION is limited or not. Why?,
    because Physical Science always find new particulate matter, smaller and
    they can not proof that "There are smallest particulate matter". Computer
    Science knows that INFORMATION is big and find the way to work with it.

    Don't misstake INFORMATION and DATA. As above example, meaning of two
    lines is INFORMATION, not two lines. Two lines is DATA and will be present
    below.

DATA
====

    It is things represents for INFORMATION. Good news, it is able to show
    "How is DATA look like?". For example, with name and gender of a person,
    human use writting language to represent to that's INFORMATION, and it is
    DATA:

        name: kevin leptons
        gender: male

    Now, above DATA have 19 + 12 = 31 characters. Characters is English
    alphabet. And of course, characters is able to see.

    INFORMATION can be represents by more than one DATA. Here is DATA in
    Spanish version with same INFORMATION above:

       nombre: kevin leptons
       g√©nero: masculino

       <by translate.google.com>

ALGORITHM
=========

    It is describes "How to work with DATA?". ALGORITHM includes three parts:

        Input: describes source DATA
        Output: describes destination DATA
        Operations: describes how to get destination DATA from source DATA

    For examples, here is ALGORITHM to find person with name:

        Input: List of person
        Output:
            On found return first person who have name
            On not found return NOT_FOUND
        Operations:
            for each person in Input:
                if name of person is same with name:
                    return person
            return NOT_FOUND

    Defination above use PESUDO_CODE but ALGORITHM can be show by any things
    such as paragraphs, images, sound or videos and it describes INPUT_DATA,
    OUPUT_DATA, OPERATIONS.

ALGORITHM'S COMPLEXITY
======================

    ALGORITHM_COMPLEXITY is function show "How OPERATION_AMOUNT change while
    input's DATA_AMOUNT change?" and applies for number ALGORITHM.

    Why ALGORITHM_COMPLEXITY applies for only number ALGORITHM?. Because it's
    definition related with two concepts OPERATION_AMOUNT which base on
    numbers.

    OPERATION_AMOUNTS is quantitive of OPERATIONS. It is calculates by sum all
    of PRIMITIVE_OPERATIONS. PRIMITIVE_OPERATIONS applies for operations with
    numbers, include: ADD, SUB, MUL, DIV, ASN, >, >=, <, <=, ==. Binary
    numbers have more PRIMITIVE_OPERATIONS, include: SHIFT, AND, OR, NOR, XOR.
    Quanlity of each PRIMITIVE_OPERATIONS is one.

    DATA_AMOUNT is quantitive of DATA, any DATA is quantitive. It is number of
    element of data. In this case, it is number of element of input data.

    For example, here is ALGORITHM to calculate total of numbers:

        Input: List with n numbers
        Output: Total of numbers of input
        Operations:
            total = 0                     			// 1
            for (i = 0; i < n; i++):                // 1; n(1 + 1)
				total = total + input[i]			// 1 + 1
            return total

    Complexity of above ALGORITHM is:

        f(n) = 1 + 1 + n(1 + 1)(1 + 1)
             = 4n + 2

BIG-O
=====

    BIG-O is notation show "What biggest factor affect to
    ALGORITHM_COMPLEXITY?". In simple, from complexity function, strip all
    of constants and chose biggest factor and it is BIG-O.

	With complex algorithms, get extract ALGORITHM_COMPLEXITY
    function is hard or depend on other factors than DATA_AMOUNT. Best way
	is use worst case of loops, strip for constants to get worst
	ALGORITHM_COMPLEXITY, then get Big-O from that function.

	For example, here is ALGORITHM to sort an list of number by increasing.

        Input: List of n numbers
        Output: List of n numbers by increasing
        Operations:
            for (i = 0; i < n - 1; i++):                // 2(n - 1)
                for (k = i + 1; k < n; k++):            // 2(n - 1)
                    if (input[i] > input[k]):           // 1
                        tmp = input[i]                  // 1
                        input[i] = input[k]             // 1
                        input[k] = tmp                  // 1
            return input

        Worst ALGORITHM_COMPLEXITY: f(n) = 2(n - 1).2(n - 1)(1 + 1 + 1 + 1)
                                         = 16(n^2 -2n - 1)
        Strip all of constants: g(n) = n^2 - n
        Chose biggest factor: BIG-0 = O(n^2)

ADT
===

    ADT is Abstract Data Type. It describes programming interfaces, includes
    INPUT_DATA, OUTPUT_DATA corresspond with input and output of ALGORITHM.
    However, it doesn't specifies OPERATIONS. People is free to implements
    ADT.

    It is possible to specify ADT by any things which can describes it.
    However, better ADT should be specify by an programming language and
    paragraphs. If possible, images is additional to help people easy to
    understand about ADT. In next sections, C language is use to describle
    ADT.

    Why ADT is useful?. Because:

        - It represents for many INFORMATION in real world
        - It is more simple to write than do from scratch
        - It is more simple to read than none ADT

ARRAYS
======

    ARRAYS use to store/retrieve items, index by sequence numbers from zero
    and size of ARRAY can not be change.

    struct array {};
    int array_init(struct array *array, size_t size);
    int array_set(struct array *array, size_t index, void *value);
    int array_get(struct array *array, size_t index, void **value);
    int array_size(struct array *array);
    int array_free(struct array *array);

    That is programming interfaces for ARRAY. However, C provide built-in
    ARRAY and people always use it instead of implement ARRAY.

    ======================================  =================================
    ARRAY interfaces                        C array interfaces
    ======================================  =================================
    struct array and array_init()           type array[size]
    array_set()                             array[index] = value
    array_get()                             value = array[index]
    array_size()                            sizeof(array) / sizeof(type)
    array_free()                            automatic after exit stack
    ======================================  =================================

VECTORS
=======

    Vector is use to store/retrieve items, index by sequence numbers from 0.

    struct vector {};
    int vector_init(struct vector *vector);
    int vector_add(struct vector *vector, void *value);
    int vector_ins(struct vector *vector, size_t index, void *value);
    int vector_del(struct vector *vector, size_t index);
    int vector_get(struct vector *vector, size_t index, void **value);
    int vector_free(struct vector *vector);
    size_t vector_size(struct vector *vector);

STACKS
======

    Stacks is use to store items and retrieve by first in last out order.

    struct stack {};
    int stack_init(struct stack *stack);
    int stack_push(struct stack *stack, void *value);
    int stack_pop(struct stack *stack, void **value);
    int stack_top(struct stack *stack, void **value);
    int stack_free(struct stack *stack);
    size_t stack_size(struct stack *stack);

QUEUES
======

    Queues is use to store items and retrieve by first in first out order.

    struct queue {};
    int queue_init(struct queue *queue);
    int queue_push(struct queue *queue, void *value);
    int queue_pop(struct queue *queue, void **value);
    int queue_top(struct queue *queue, void **value);
    int queue_free(struct queue *queue);
    size_t queue_size(struct queue *queue);

GRIDS
=====

    Grid is use to store/retrieve items with two indexes, row and col.
    Size of grid is not automatic change, it require specific call to do
    that.

    struct grid {};
    int grid_init(struct grid *grid, size_t row_size, size_t col_size);
    int grid_resize(struct grid *grid, size_t row_size, size_t col_size);
    int grid_set(struct grid *grid, size_t row, size_t col, *value);
    int grid_get(struct grid *grid, size_t row, size_t col, **value);
    int grid_free(struct grid *grid);
    size_t grid_row_size(struct grid *grid);
    size_t grid_col_size(struct grid *grid);

STRINGS
=======

    String is use to work with sequence characters.

    struct str {};
    int str_init(struct str *str);
    int str_cmp(struct str *left, struct str *right);
    int str_clr(struct str *str, size_t index, size_t len);
    int str_cpy(struct str *dest, struct str *src);
    int str_ins(struct str *dest, size_t index, struct string *part);
    int str_rpl(struct str *dest, size_t index, size_t len, struct str *part);
    int str_cat(struct str *dest, struct str *part);
    int str_free(struct str *str);
    int str_get(struct str *str, size_t index, char *value);
    int str_set(struct str *str, size_t index, char value);
    struct str * str_sub(struct str *str, size_t index, size_t len);
    struct str * str_clone(struct str *str);
    size_t str_size(struct str *str);

MAPS
====

    MAPS is use to store/retrieve items index by key. Key can be any type,
    however any type can convert into string. Here are MAPS with string key:

    struct map {};
    int map_init(struct map *map);
    int map_get(struct map *map, const char *key, void **value);
    int map_set(struct map *map, const char *key, void *value);
    int map_free(struct map *map);
    size_t map_size(struct map *map);
    struct vector * map_keys(struct map *map);

LINKED LIST
===========

    It is data structure is use to store/retrieve items by references. Each
    item havs two neighbours: next and prev. Depend on using of LINKED_LIST,
    an item has references to next, prev or both neigbours.  LINKED_LIST is
    use to implement STACK and QUEUE.  Here is some type of LINKED_LIST.

    struct lklist {                     // two way linked
        struct lklist *next;
        struct lklist *prev;
        // other properties...
    };

    struct lklist_fw {                  // forward linked
        struct lklist *next;
        // other properties...
    };

    struct lklist_bk {                  // back linked
        struct lklist *prev;
        // other properties...
    }

TREES
=====

    It is data structure and is defined by recursion. Tree can be empty or
    not. If tree is not empty, it includes references to children tree.
    Children tree can be empty, it mean that tree have not children. Depend on
    using, tree can be different. Here is some types:

    struct tree {};
    int tree_init(struct tree *t);
    int tree_cadd(struct tree *t, struct tree *child);
    int tree_cdel(struct tree *t, struct tree *child);

    struct tree_bin {                   // binary tree
        struct tree *left;
        struct tree *right;
        // other properties of tree...
    };

    struct tree_tnr {                   // ternary tree
        struct tree_tnr *left;
        struct tree_tnr *mid;
        struct tree_tnr *right;
        // other properties of tree...
    };

    struct tree {                       // n-ary tree
        struct tree *children;
        // other properties of tree...
    };


BINARY_HEAPS
============

    It is binary tree with more specification. If tree is mark by order from
    tree, left child and right child, left child and right child MUST be fills
    before create new children of prev tree. Each tree contains an number
    called tree's value. Binary tree divides into two types. First,
    SMALLEST_BINARY_TREES, in that tree, tree's value MUST smaller or equal
    children tree's value. Second, BIGGEST_BINARY_TREES, in that tree, tree's
    value MUST bigger or equal children tree's value. To ensure specification
    is correct, two ALGORITHMS are provides:

    struct bheap {};
    int bheap_add(struct bheap *heap, size_t value);
    int hheap_del(struct bheap *heap, struct bheap *node);

BINARY_SEARCH_TREES
===================

    It is binary tree with more specific. Each tree contaisn an number called
    tree's value. Tree's value of left trees MUST smaller than tree's value
    and tree's value of right tree MUST bigger than tree's value. To ensure
    specificaion is correct four ALGORITHMS are provides:

    struct bst {};
    int bst_add(struct bst *tree, size_t value);
    int bst_del(struct bst *tree, struct bst *node);
    size_t bst_min(struct bst *tree);
    size_t bst_max(struct bst *tree);

GRAPHS
======

    It is concept contains set of nodes and edges. Each edges is define by
    two nodes. With UNDIRECTED_GRAPHS, two nodes of edges is not order. with
    DIRECTED_GRAPH, two nodes of edges is order and called START_NODE and
    END_NODE.

    struct graph_vertex {};
    struct graph_edge {};
    struct graph {};
    int graph_init(struct graph *g);

    int graph_vadd(struct graph *g, size_t id);
    int graph_vdel(struct graph *g, size_t id);
    struct graph_vertex * graph_vget(struct graph *g, size_t id);
    struct pset * graph_vertexs(struct graph *g);

    int graph_eadd(struct graph *g, size_t begin, size_t end);
    int graph_edel(struct graph *g, size_t begin, size_t end);
    struct graph_edge * graph_eget(struct graph *g, size_t begin , size_t end);
    struct pset *graph_edges(struct graph *g);

    int graph_find(struct graph *g, size_t begin, size_T end, vector *path);
    int graph_walk(struct graph *g, void (*callback)(struct graph_vertex *v));

RECURSIONS
==========

    Recursions is an ALGORITHM which have OPERATIONS group into two cases:
    call itself or not.

    Here is general example about RECURSIONS ALGORITHM:

        Name: general_fn
        Input: number
        Output: number
        Operation:
            case 1: return NUMBER
            case 2: general_fn(number)

    Look for specific example, calculate factorial of n.
    Because n! = n(n - 1)! with n > 1 and 1! = 1, so:

        Name: factorial
        Input: Number called n
        Output: Factorial of n
        Operations:
            if (n == 1):
                return 1
            else
                return n * factorial(n - 1)

RECURSION BACKTRACKING
======================
